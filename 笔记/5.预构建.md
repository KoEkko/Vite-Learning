

为什么需要预构建？

1. 首先Vite是基于浏览器原生ES模块规范实现的Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合ESM规范才能够正常运行
2. **请求瀑布流问题**，比如说，`loadsh-es`库本身是有ES版本产物的，可以在Vite中直接运行。但实际上，它在加载时会发出特别多的请求，导致页面加载的前几秒几乎都处于卡顿状态，我在应用代码中调用了 debounce 方法，这个方法会依赖很多工具函数，每个`import`语句都会触发一次新的文件请求，因此在这种**依赖层级深、涉及模块数量多**的情况下，会触发很多个网络请求，再加上Chrome对同一个域名下只能同时支持 6 个HTTP并发请求的限制，导致页面加载十分缓慢，在依赖的预构建之后，loadsh-es这个库的代码被打包成一个文件，这样请求的数量会骤然减少，页面加载也快了很多

总之，依赖预构建做了两件事情：

1. 将其他格式（如UMD和CJS）的产物转换为ESM格式，使其在浏览器通过`<script type="module"></ script>` 的方式正常加载
2. 打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少HTTP请求数量，避免页面加载性能劣化。


如何开启依赖预构建：自动开启 和 手动开启

# 自动开启
项目启动成功后，可以在根目录下的 `node_modules`中发现`.vite`目录，这就是预构建产物文件存放的目录

在浏览器访问页面后，第三方包的引入路径已经被重写，并且对于依赖的请求结果，Vite的Dev Server会设置强缓存。除了HTTP缓存，Vite还设置了本地文件系统的缓存，所有的预构建产物默认缓存在`node_modules/.vite`目录中

# 手动开启

预构建中本地文件系统的产物缓存机制在少数场景下我们不希望使用，比如需要调试某个包的预构建结果，清除缓存的方法：
1. 删除`node_modules/.vite`目录
2. 在Vite配置文件中，将`server.force`设为`true`
3. 命令行执行`npx vite --force` 或者 `npx vite optimize`


# 自定义配置

预构建相关的配置项都集中在`optimizeDeps`属性上

## 入口文件-entries

通过`optimizeDeps.entries`可以自定义预构建的入口文件。
Vite在默认情况下会抓取项目中所有的HTML文件，将HTML文件作为应用入口，然后根据入口文件扫描出项目中用到的第三方依赖，最后对这些依赖逐个进行编译


## 添加一些依赖-include

可以强制预构建的依赖项

使用场景一：动态import

在某些动态import的场景下，由于Vite天然按需加载的特性，经常会导致某些依赖只能在运行时被识别出来，无法在预构建阶段被扫描出来，Vite运行时发现了新的依赖，会重新进行依赖预构建，并刷新页面，这个过程叫做二次预构建。
二次预构建的成本很大，不仅需要吧预构建的流程重新运行一遍，还得重新刷新页面，并且需要重新请求所有的模块，所以我们要避免运行时的二次预构建。

可以通过`include`参数提前声明需要按需加载的依赖

使用场景二：某些包被手动exclude

配置了exclude后，这个包不再进入到依赖预构建的过程，但是这个包本身所依赖的其他包会有格式要求，才能正确的进行预构建

比如我们手动exclude的包本身具有ESM格式的产物，但他的某个依赖的产物并没有提供ESM格式，导致运行时加载失败

这个时候include配置就派上用场了，可以强制对这个间接依赖包进行预构建
